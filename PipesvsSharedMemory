Both methods allow multiple threads or processes to communicate amongst themselves. The difference between them is the way the data is shared.

Pipes are like binary Snapchat. It is a point-to-point one-time data transport. I put data in at one end, and, unlike shared memory, one, just one, process receives it. If a program is told to receive something from some pipe, it will automatically pause and wait for something to come out. Once the program reads the incoming, it's gone from the pipe. Even the sender can't see the data it piped out. If you want to set up two-way communication, you can make pipes that face both ways. The pipe's buffer has a theoretical limit of 4kB, so packages have to be read by the receiver often to avoid clogging up the buffer. If the buffer gets clogged with unread data, you can perform the sacred pipe flush, which cleanses the buffer of unnecessary data. Do this often enough, and 'buffer overflow' will never be a problem.


Shared memory is like Google Docs. One process can write some data to it, and many others can read it, modify it, vandalize it, clear it, etc. This process is much less user-friendly than piping, as programs must be told when to check the shared memory for updates, however it has the benefit of allowing many processes to access the same data. You can also choose how much memory to allocate to the share, while pipes do this automagically. The sender can later review the data it put into the memory, but other processes can then modify it. This is useful if you have several processes that want to access the data at once (i.e. camera output), and no one program receives it all.
